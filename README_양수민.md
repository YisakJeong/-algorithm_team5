# 문제4

4번 문제는 주어진 배열(n x n) 내에서 출발점 (0,0)부터 도착점(값이 0)까지 도달 가능한 모든 경로를 탐색하여 도달 가능한 모든 경로를 출력하고 그 중 방문한 칸의 숫자 합이 가장 적은 경로와 그 합을 출력하는 문제이다.
각 칸의 숫자는 해당 칸에서 한 번에 이동 가능한 칸 수를 나타내고 상하좌우로 이동 가능하다.
경로 탐색에는 1초의 제한 시간과 256MB의 메모리 제한이 있다.

### method

재귀 함수를 이용한 DFS 방식으로 현재 위치에서 이동 가능한 모든 경로를 탐색하였습니다.

경로는 path에 리스트 형식으로 저장해주었고, 도착점에 도달한 경우 해당 경로를 all_paths에 저장하였습니다.

time().time()을 사용하여 탐색을 시작하고 1초가 넘게 걸리는 경우 멈추도록 하였습니다.

또한 tracemalloc 모듈을 이용하여 현재 사용 중인 메모리가 256MB를 넘는 경우에도 멈추도록 하였습니다.

무한 루프를 방지하기 위해 visited 2차원 리스트를 사용하여 방문한 곳을 기록하여주었습니다.

최종적으로 저장된 경로들을 하나씩 출력하고, 가장 적은 칸 수로 도달한 경로와 그 총 합도 함께 출력하도록 하였습니다.


# 문제 6

6번 문제는 위의 4번 문제와 비슷한 문제이다.

주어진 배열(n x n)에서 시작점 S에서 도착점 E까지 도달할 수 있는 경로가 있는지 확인하는 문제이고, 만약 존재한다면 이동 경로와 총 이동 거리를 출력하며, 존재하지 않는다면 존재하지 않는다고 출력하는 문제이다.
4번 문제와 다른 점은 벽(#)이 존재하며, 칸에 숫자가 적혀 있지 않다는 것이다.

### method

4번 문제와 동일하게 재귀 함수를 이용하여 DFS 알고리즘을 사용하여 현재 위치에서 상하좌우로 이동하며 도착점까지의 경로를 찾아주었습니다.

배열을 벗어나거나 벽이거나 이미 방문한 적이 있는 칸을 다시 방문하게 되는 경우 멈추도록 하였습니다.

현재 위치가 E인 경우 TRUE를 반환하여 경로를 확정지어줍니다.

최종적으로 도달 가능한 경로를 찾은 경우 찾았다는 프린트문과 함께 총 이동 거리를 출력하게 하였습니다.

도달 가능 경로가 없는 경우 찾지 못했다는 프린트문을 출력하게 하였습니다.
